---
title: "Tutorial: Spatial Regression in R"
subtitle: "Assessing Autocorrelation, Modeling Correlation Structures, and Spatial Autoregressive Models"
author: "René Gier Vemmelund"
date: "`r format(Sys.Date(), '%d %B %Y')`"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    theme: cosmo
    highlight: tango
    number_sections: true
editor_options: 
  chunk_output_type: console
bibliography: references.bib
link-citations: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, warning = FALSE, message = FALSE, error = TRUE)
```

# Introduction

Welcome to this tutorial on spatial regression! Spatial data often violates the independence assumption of classical regression because observations close in space tend to be more similar than those far apart. This tutorial will guide you through:

- **Detecting spatial autocorrelation** using Moran's I and semivariograms
- **Fitting basic regression models** and assessing residuals
- **Incorporating spatial correlation structures** into mixed-effects models
- **Comparing different spatial correlation models**
- **Evaluating model performance** and reporting findings

We'll use vegetation data from the **sPlotOpen** database, focusing on European plant communities to understand how environmental factors influence species richness while accounting for spatial dependencies.

## Learning Objectives

By the end of this tutorial, you will be able to:

1. Detect violations of independence due to spatial autocorrelation
2. Assess spatial autocorrelation in model residuals
3. Fit mixed-effects models with spatial correlation structures
4. Compare exponential, Gaussian, and spherical correlation structures
5. Evaluate and select optimal models using AIC and likelihood ratio tests
6. Interpret and report spatial regression results

### Some Information on the Data-set Used

The data you'll be working with in this computer lab comes from a project called [*sPlot*](https://www.idiv.de/en/sdiv/working_groups/wg_pool/splot/about_the_project.html), an initiative of the [German Centre for Integrative Biodiversity Research (iDiv)](https://www.idiv.de/en/index.html). The complete *sPlot* database covers a wide range of locations but has uneven coverage and is not publicly available. However, [@sabatini2021] addressed these issues by carefully selecting, organising, and obtaining permission from data owners of 105 different local and regional data-sets to make some of them open to the public. This led to the creation of **sPlotOpen**, the largest freely available collection of plot-based vegetation data. This data-set can be used to study global plant diversity, assist with remote sensing tasks, or track biodiversity changes over time.

*sPlotOpen* contains data from around the world. We use a European subset of the data for this session —sites with over ten species and sampling areas above 10m^2^. For each site, data includes species richness (number of different species per plot - `Species_richness`), location (longitude and latitude - `Longitude`,`Latitude`), country (`Country`), plot size (in square meters- `Releve_area`), geographical features (elevation, slope, aspect - `Elevation`, `Aspect`, and `Slope`), and environmental variables (loading on Principal Component axes 1 and 2 (`SoilClim_PC1`,`SoilClim_PC2`) based on climate and soil conditions derived by [@sabatini2021], and the [Environmental Stratification Class](https://www.wur.nl/en/research-results/research-institutes/environmental-research/projects/ebone/products/european-environmental-stratification.htm) - `Env.Strat`; derived by [@metzger2005]).

## Essential Functions Reference

| Task | Function | Package |
|------|----------|---------|
| Linear model | `lm()` | stats |
| GLS model | `gls()` | nlme |
| Mixed-effects model | `lme()` | nlme |
| Moran's I | `Moran.I()` | ape |
| Moran's I test | `moran.test()` | spdep |
| Moran plot | `moran.plot()` | spdep |
| Neighbors | `knn2nb()`, `knearneigh()` | spdep |
| Weights | `nb2listw()` | spdep |
| Variogram | `Variogram()` | nlme |
| Variogram | `variogram()` | gstat |
| Exponential correlation | `corExp()` | nlme |
| Gaussian correlation | `corGaus()` | nlme |
| Spherical correlation | `corSpher()` | nlme |
| Model comparison | `AIC()`, `anova()` | stats |
| Cross-validation | `train()`, `trainControl()` | caret |
---

# Part 1: Data Preparation and Exploration

## 1.1 Load Required Packages

```{r load-packages}
# Load packages for spatial analysis
library(nlme)     # For mixed-effects models with spatial correlation
library(dplyr)     # For data manipulation
library(ggplot2)     # For visualization
library(sf)     # For simple features (spatial data)
library(spdep)     # For spatial weights and Moran's I
library(gstat)     # For geostatistics and variograms
library(ape)     # For phylogenetic statistics (includes Moran.I)
library(sp)     # For spatial classes
library(lmtest)     # For testing heteroscedasticity
library(caret)     # For k-fold validation
```

**HINT:** Packages needed are: `nlme`, `dplyr`, `ggplot2`, `sf`, `spdep`, `gstat`, `ape`, `sp`, `lmtest`,`caret`

## 1.2 Load and Explore the Data

```{r load-data}
# Load the sPlot data
sPlot.Data <- read.csv("Splot_SppRichness.csv")

# Explore data structure
str(sPlot.Data)

# View summary statistics
summary(sPlot.Data)

# Check the first few rows
head(sPlot.Data)
```

**TASK:** Fill in functions to read CSV files, examine structure, summarize, and view the first rows.

## 1.3 Data Cleaning and Standardization

```{r clean-data}
# Remove missing values
sPlot.Data <- na.omit(sPlot.Data)

# Standardize continuous predictors
sPlot.Data$Elevation <- scale(sPlot.Data$Elevation)
sPlot.Data$Slope <- scale(sPlot.Data$Slope)
```

**TASK:** Fill in the function to remove NAs and the function to standardize variables (z-scores).

## 1.4 Visualize Spatial Distribution

```{r visualize-spatial}
# Create a basic spatial plot of species richness
ggplot(sPlot.Data) +
  geom_point(aes(x = Longitude, y = Latitude, color = Species_richness)) +
  scale_color_viridis_c() +
  theme_minimal() +
  labs(title = "Spatial Distribution of Species Richness",
       x = "Longitude", y = "Latitude")
```

**TASK:** Fill in the geom function for points and the aesthetic mappings (x, y, color).

```{r visualize-sf}
# Convert to sf object for better spatial visualization
data_sf <- st_as_sf(x = sPlot.Data, 
                 coords = c("Longitude", "Latitude"), 
                 crs = 4326)

# Plot using geom_sf
ggplot(data_sf) +
  geom_sf(aes(colour = Species_richness)) +
  scale_color_viridis_c() +
  theme_minimal() +
  labs(title = "Spatial Distribution of Species Richness")
```

**TASK:** Fill in the function to create sf objects, its arguments (data, coords, crs), coordinate column names, and the geom for sf objects.

---

# Part 2: Detecting Spatial Autocorrelation

## 2.1 Understanding Spatial Autocorrelation Concepts

**Key Concepts:**

- **Spatial Autocorrelation**: The correlation of a variable with itself through space
  - *Positive*: Similar values cluster together (high near high, low near low)
  - *Negative*: Dissimilar values are neighbors (high near low)
  - *Zero*: Random spatial pattern

- **Moran's I**: Quantifies spatial autocorrelation
  - Ranges from -1 (dispersion) to +1 (clustering)
  - Values near 0 suggest randomness

- **Semivariogram**: Shows how similarity decreases with distance
  - *Nugget*: Variability at zero distance (measurement error)
  - *Range*: Distance where correlation diminishes
  - *Sill*: Plateau indicating total variance

## 2.2 Calculate Moran's I

### Method 1: Using the `ape` package

```{r morans-i-ape}
# Create coordinate matrix
coords <- tibble(sPlot.Data$Longitude, sPlot.Data$Latitude)

# Calculate distance matrix
dist_matrix <- as.matrix(dist(coords))

# Create inverse distance weight matrix
inv_dist_matrix <- 1 / dist_matrix
diag(inv_dist_matrix) <- 0  # Set diagonal to 0

# Calculate Moran's I using ape
library(ape)
moran_result <- Moran.I(x = sPlot.Data$Species_richness,
                      weight = inv_dist_matrix,
                      scaled = TRUE,
                      na.rm = TRUE)

# Display results
print(moran_result)
```

**TASK:** Fill in functions to combine columns, calculate distances, and compute Moran's I with appropriate arguments.

### Method 2: Using the `spdep` package

```{r morans-i-spdep}
# Create neighbor structure (4 nearest neighbors)
library(spdep)
nb <- knn2nb(knearneigh(coords, k = 4))

# Create spatial weights list
listw <- nb2listw(nb, style = "W")

# Compute Moran's I test
moran.test(x = sPlot.Data$Species_richness, 
          listw = listw)
```

**TASK:** Fill in functions to create k-nearest neighbors, convert to neighbor list, create weights, and perform Moran's test.

## 2.3 Visualize Moran's I with a Moran Plot

A Moran scatterplot showing relationship between a variable and the average value of its neighbors for the same variable 
It is instructive to consider each quadrant of the plot. In the upper-right quadrant are cases where both the value and local average value of the attribute are higher than the overall average value. Similarly, in the lower-left quadrant are cases where both the value and local average value of the attribute are lower than the overall average value. These cases confirm positive spatial autocorrelation. Cases in the other two quadrants indicate negative spatial autocorrelation. Depending on which groups are dominant, there will be an overall tendency towards positive or negative (or perhaps no) spatial autocorrelation.

```{r moran-plot-manual}
# Create Moran plot data manually (using ape approach)
DataMoranPlot <- data.frame(
  LaggedValues = scale(as.numeric(inv_dist_matrix %*% sPlot.Data$Species_richness)),
  StandardizedValues = scale(sPlot.Data$Species_richness)
)

# Create Moran plot
plot(StandardizedValues ~ LaggedValues, 
     data = DataMoranPlot,
     main = "Moran Plot",
     xlab = "Standardized Values", 
     ylab = "Spatially Lagged Values")
abline(h = 0, v = 0, col = "gray")
abline(lm(LaggedValues ~ StandardizedValues, data = DataMoranPlot), 
       col = "red")
```

**TASK:** Fill in the formula notation for the plot and the function to fit a linear model. 


```{r moran-plot-spdep}
# Moran plot using spdep
moran.plot(x = sPlot.Data$Species_richness, 
          listw = listw,
          main = "Moran Plot of Species Richness")
```

**TASK:** Fill in the function and arguments for creating a Moran plot.

## 2.4 Interpret Moran's I Results

**Your Interpretation:**

- Moran I Statistic: **0.2298** 
- P-value: **2.2e-16** 
- Conclusion: Is there significant spatial autocorrelation? *Yes, there is significant spatial autocorrelation.*
- Type: Is it positive or negative autocorrelation? *It is positive, as the Moran I is positive.*
- Implication: What does this mean for your analysis? *This means that plot that are closer to each other are more similar in species richness.*

---

# Part 3: Basic Linear Regression and Residual Analysis

## 3.1 Fit a Basic Linear Model

```{r fit-lm}
# Fit linear model without spatial components
lm_model <- lm(Species_richness ~ Elevation + Slope + SoilClim_PC1 + SoilClim_PC2,
                  data = sPlot.Data)

# View model summary
summary(lm_model)
```

**TASK:** Fill in the function to fit linear models, the response variable, and the dataset.

## 3.2 Diagnostic Plots

```{r diagnostic-plots}
# Create diagnostic plots
par(mfrow = c(2, 2))
plot(lm_model)
```

**TASK:** Fill in the function to create diagnostic plots.

## 3.3 Test for Heteroscedasticity

A formal statistical test you can use to determine if heteroscedasticity is present is the Breusch-Pagan test. The test uses the following null and alternative hypotheses:

* Null Hypothesis (H0): Homoscedasticity is present (the residuals are distributed with equal variance)
* Alternative Hypothesis (HA): Heteroscedasticity is present (the residuals are not distributed with equal variance)

If the $p$-value of the test is less than some significance level (i.e. $\alpha$ = 0.05) then we reject the null hypothesis and conclude that heteroscedasticity is present in the regression model.

```{r test-heteroscedasticity}
# Breusch-Pagan test for heteroscedasticity
library(lmtest)
bptest(lm_model)
```

**TASK:** Fill in the function to perform the Breusch-Pagan test.

## 3.4 Test Residuals for Spatial Autocorrelation

```{r residual-moran}
# Extract residuals
lm_residuals <- resid(lm_model)

# Moran's I on residuals (using ape)
Moran.I(x = lm_residuals,
     weight = inv_dist_matrix,
     scaled = TRUE,
     na.rm = TRUE)

# Moran's I on residuals (using spdep)
moran.test(x = lm_residuals, 
          listw = listw)
```

**TASK:** Fill in functions to extract residuals and compute Moran's I on residuals.

**Question:** Do the residuals show spatial autocorrelation? What does this indicate about the model?
*Yes, the model's residuals show positive spatial autocorrelation, as the Moran I is significantly larger than 0. This indicates that the residual variance in predicting the species richness from the env variables, varies spatially. So observations closer in space are more similar in their residual variance.*

---

# Part 4: Semivariogram Analysis

## 4.1 Fit a GLS Model for Variogram Analysis

```{r fit-gls}
# Fit generalized least squares model
library(nlme)
gls_model <- gls(Species_richness ~ Elevation + Slope + SoilClim_PC1 + SoilClim_PC2,
                   data = sPlot.Data)

# View summary
summary(gls_model)
```

**TASK:** Fill in the function to fit GLS models, the formula, and dataset.

## 4.2 Calculate and Plot Variogram (Method 1: nlme)

```{r variogram-nlme}
# Estimate variogram from GLS model
Vario1 <- Variogram(object = gls_model,
                form = ~ Longitude + Latitude,
                robust = TRUE,
                maxDist = 0.5,
                resType = "normalized")

# Plot variogram
plot(Vario1, smooth = TRUE)
```

**TASK:** Fill in the function to calculate variogram, its arguments, coordinate names, and plotting function.

## 4.3 Calculate and Plot Variogram (Method 2: gstat)

```{r variogram-gstat}
# Add residuals to data
sPlot.Data$residuals <- resid(gls_model)

# Convert to spatial object
library(sp)
sPlot.Spat <- sPlot.Data
coordinates(sPlot.Spat) <- ~ Longitude + Latitude

# Calculate variogram
library(gstat)
# Use Cressie–Hawkins robust estimator (optional, for outlier resistance)
Gstat_variogram <- variogram(residuals ~ 1, 
                             data = sPlot.Spat, 
                             cutoff = 0.5, 
                             width = 0.05,      # adjust lag bin width as needed
                             cressie = TRUE)

# --- Fit a theoretical variogram model ---
# Initial guess for parameters: adjust psill, range, and nugget to your data scale
vgm_model_init <- vgm(psill = var(sPlot.Spat$residuals, na.rm = TRUE) * 0.8,
                      model = "Exp", 
                      range = 0.2, 
                      nugget = var(sPlot.Spat$residuals, na.rm = TRUE) * 0.2)

# Fit model to empirical variogram
Gstat_fit <- fit.variogram(Gstat_variogram, vgm_model_init)

# --- Plot results ---
plot(Gstat_variogram, Gstat_fit, 
     main = "Empirical and Fitted Variogram (gstat)",
     xlab = "Distance", 
     ylab = "Semivariance")
```

**TASK:** Fill in functions to extract residuals, set coordinates (using the special assignment operator), and calculate variogram.

## 4.4 Interpret the Semivariogram

**Your Interpretation:**

1. What is the nugget (intercept at distance 0)? *0.65. The nugget represents measurement error and variation at small scales.*
2. What is the approximate range (distance where it plateaus)? *0.3 decimal degrees, meaning spatial correlation weakens and levels off beyond this distance.*
3. What is the sill (plateau value)? *0.9. This plateau indicates the limit of spatial dependence*
4. Does the variogram suggest spatial autocorrelation? *Yes, the semivariance increases with distance before reaching the sill, showing positive spatial autocorrelation at short distances.*
5. What spatial structure is indicated? *The slope seems to increase as distance decreases and the range is relatively long, so the spatial structure looks exponential.*

---

# Part 5: Mixed-Effects Models with Spatial Correlation Structures

## 5.1 Understanding Spatial Correlation Structures

**Three Common Structures:**

1. **Exponential** (`corExp`):
   - Rapid initial decay, long tails
   - Correlation gradually decreases with distance
   - Good for moderate to strong short-range autocorrelation

2. **Gaussian** (`corGaus`):
   - Smooth, rapid decay
   - Correlation drops to zero quickly
   - Good for smooth spatial patterns

3. **Spherical** (`corSpher`):
   - Linear increase in semivariance, then levels off
   - Has a defined range beyond which correlation is zero
   - Good for processes with finite spatial influence

## 5.2 Fit Model with Exponential Correlation Structure

```{r fit-exponential}
# Fit mixed-effects model with exponential spatial correlation
exponential_model <- lme(Species_richness ~ Elevation + Slope + SoilClim_PC1 + SoilClim_PC2,
                           random = ~ 1 | Country,  # Random intercept by Country
                           correlation = corExp(form = ~ Longitude + Latitude),
                           data = sPlot.Data)

# View summary
summary(exponential_model)

# Compare to basic GLS
anova(exponential_model, gls_model)
```

**TASK:** Fill in the function for mixed-effects models, response variable, random effect grouping variable, correlation structure function, coordinate formula, dataset, and comparison function.

## 5.3 Fit Model with Gaussian Correlation Structure

```{r fit-gaussian}
# Update with Gaussian correlation structure
gaussian_model <- update(object = exponential_model, 
                        correlation = corGaus(form = ~ Longitude + Latitude))

# View summary
summary(gaussian_model)

# Compare to GLS
anova(gaussian_model, gls_model)
```

**TASK:** Fill in the function to update models and the Gaussian correlation structure function.

## 5.4 Fit Model with Spherical Correlation Structure

```{r fit-spherical}
# Update with Spherical correlation structure
spherical_model <- update(exponential_model, 
                          correlation = corSpher(form = ~ Longitude + Latitude))

# View summary
summary(spherical_model)

# Compare to GLS
anova(spherical_model, gls_model)
```

**TASK:** Fill in the spherical correlation function and coordinate formula.

---

# Part 6: Model Comparison and Selection

## 6.1 Compare Models Using AIC

```{r compare-aic}
# Compare all models using AIC
AIC(gls_model, exponential_model, gaussian_model, spherical_model)
```

**TASK:** Fill in the function to calculate AIC and the four model objects to compare.

## 6.2 Likelihood Ratio Tests

```{r compare-lrt}
# Likelihood ratio test comparing spatial models
anova(exponential_model, gaussian_model, spherical_model)
```

**TASK:** Fill in the function to perform ANOVA comparison of multiple models.

## 6.3 Summarize Model Comparison

Create a table summarizing the model comparison:

| Model | df | AIC | BIC | logLik | Best? |
|-------|-----|-----|-----|--------|-------|
| GLS (no spatial) | 6 | -284.5947 | -256.0045 | 148.2974 | ___ |
| Exponential | 8 | -355.5954 | -317.4751 | 185.7977 | ___ |
| Gaussian | 8 | -355.4372 | -317.3169 | 185.7186 | ___ |
| Spherical | 8 | -354.5857 | -316.4654 | 185.2929 | ___ |

**Question:** Which model has the lowest AIC? Is this model significantly better than the others?
*The exponential model has the lowest AIC, but it is not significantly better than the other two spatial models, as the difference of AIC of the spatial models is within 2.*

---

# Part 7: Model Refinement and Validation

## 7.1 Fine-Tune the Best Model

```{r tune-model}
# Add nugget parameter to the best model
spatial_model_tuned <- update(object = exponential_model,
                             correlation = corExp(form = ~ Longitude + Latitude, 
                                                 nugget = TRUE))

# View summary
summary(spatial_model_tuned)

# Check variogram of tuned model
Vario_tuned <- Variogram(spatial_model_tuned,
                         form = ~ Longitude + Latitude,
                         robust = TRUE,
                         maxDist = 20,
                         resType = "normalized")
plot(Vario_tuned, smooth = TRUE)
```

**TASK:** Fill in the function to update models and the nugget argument.

## 7.2 Cross-Validation

```{r cross-validation}
# Create folds for 5-fold cross-validation
set.seed(123)
Folds <- createFolds(sPlot.Data$X, k = 5)


# Perform cross-validation
CV <- sapply(1:5, function(i) {
  Train <- update(spatial_model_tuned, data = sPlot.Data[Folds[[i]], ])
  Test <- predict(Train, sPlot.Data[-Folds[[i]], ])
  Test - sPlot.Data$Species_richness[-Folds[[i]]]
})

# Test if average deviation is different from 0
t.test(unlist(CV))

# Calculate RMSE
RMSE <- sqrt(mean(unlist(CV)^2, na.rm = TRUE))
print(paste("RMSE:", round(RMSE, 3)))

# Calculate MAE
MAE <- mean(abs(unlist(CV)), na.rm = TRUE)
print(paste("MAE:", round(MAE, 3)))
```

**TASK:** Fill in functions for getting dimensions, updating models, making predictions, and performing t-test.

**REMEMBER**: Root Mean Squared Error (RMSE; i.e., the square-Root of the the mean of the squared residuals) and Mean Absolute Error (MAE; i.e., the mean of the absiklute residuals) are metrics used to evaluate a Regression Model. These metrics tell us how accurate our predictions are and, what is the amount of deviation from the actual values.
---

# Part 8: Model Visualization and Interpretation

## 8.1 Observed vs. Predicted Plot

```{r obs-pred-plot}
# Get predicted values
predicted_values <- predict(exponential_model, sPlot.Data)

# Create plot
ggplot(sPlot.Data, aes(x = Species_richness, y = predicted_values)) +
  geom_point(alpha = 0.5) +
  geom_abline(slope = 1, intercept = 0, color = "red", linewidth = 1) +
  theme_minimal() +
  labs(title = "Observed vs. Predicted Species Richness",
       x = "Observed Species Richness",
       y = "Predicted Species Richness")
```

**TASK:** Fill in the predict function, dataset, data frame for ggplot, x and y aesthetics, and geom for points.

## 8.2 Spatial Map of Residuals

```{r residual-map}
# Add residuals to spatial data
data_sf$residuals <- resid(exponential_model)

# Plot residuals spatially
ggplot(data_sf) +
  geom_sf(aes(color= residuals)) +
  scale_color_gradient2(low = "blue", mid = "white", high = "red", 
                       midpoint = 0) +
  theme_minimal() +
  labs(title = "Spatial Pattern of Model Residuals",
       color = "Residuals")
```

**TASK:** Fill in functions to extract residuals and create sf geometry plot.

## 8.3 Check Residual Autocorrelation

```{r check-final-residuals}
# Extract residuals from spatial model
spatial_residuals <- residuals(exponential_model, type = "normalized")

# Moran's I on spatial model residuals
Moran.I(x = spatial_residuals,
        weight = inv_dist_matrix,
        scaled = TRUE,
        na.rm = TRUE)

# Compare to original residuals
cat("\nMoran's I for LM residuals:\n")
Moran.I(x = lm_residuals, weight = inv_dist_matrix, 
        scaled = TRUE, na.rm = TRUE)
```

**Question:** Has the spatial correlation in residuals been reduced? By how much? *Yes, by 0.06. So including exponential spatial autocorrelation lowers spatial correlation in residuals.*

---

# Part 9: Reporting Results

## 9.1 Model Summary Table

**Fixed Effects:**

| Predictor | Estimate | Std. Error | t-value | p-value | Interpretation |
|-----------|----------|------------|---------|---------|----------------|
| Intercept | 1.3322544 | 0.03263982 | 40.81684 | 0.0000 | Significant |
| Elevation | -0.0611915 | 0.01357783 | -4.50672 | 0.0000 | Significant |
| Slope | 0.0039849 | 0.00757767 | 0.52588 | 0.5991 | Not significant |
| SoilClim_PC1 | -0.0181457 | 0.01321229 | -1.37339 | 0.1700 | Not significant |
| SoilClim_PC2 | 0.0093179 | 0.00679275 | 1.37175 | 0.1705 | Not significant |

## 9.2 Random Effects and Spatial Structure

**Random Effects:**
- Country random intercept SD: 0.09481101
- Residual SD: 0.1878598

**Spatial Correlation Structure:**
- Type: Exponential (Exponential/Gaussian/Spherical)
- Range parameter: 0.3
- Nugget: 0.6

## 9.3 Model Performance

- AIC: -355.5954
- BIC: -317.4751
- RMSE: 0.197
- MAE: 0.161
- Reduction in Moran's I: 0.12 to 0.06

## 9.4 Write Your Interpretation

*Write a paragraph summarizing your findings:*

1. Which environmental variables significantly affect species richness? *Only Elevation significantly affects species richness (p < 0.001). All other predictors: Slope, SoilClim_PC1, and SoilClim_PC2, were not statistically significant (p > 0.05).*
2. What is the direction and magnitude of these effects? *Elevation has a negative effect -> species richness decreases as elevation increases. So, for every SD increase in elevation, predicted richness decreases by about 0.06 units.*
3. How much spatial autocorrelation was present initially? *The residuals from the lm model show strong, significant positive spatial autocorrelation: Moran’s I = 0.120 (expected = −0.001) and p < 0.001. Because the observed value is well above the expected random value and highly significant, nearby sites have more similar species-richness than distant ones -> clear spatial clustering.*
4. How well did the spatial model address the autocorrelation? *After fitting the exponential spatial model, Moran I dropped to 0.06 (expected = –0.0011, p ≈ 1 × 10⁻⁶). Although still statistically significant, the magnitude of Moran’s I was less than half of the lm model value, showing that the spatial model greatly reduced but did not completely eliminate residual spatial autocorrelation.*
5. What are the practical implications of your findings? *The analysis shows that elevation is the primary env driver of species richness (for the variables checked), with richness decreasing significantly at higher elevations. Although the spatial model reduced spatial autocorrelation, some spatial dependence remained, indicating that unmeasured spatial processes may still be present. From a practical standpoint, these findings highlight the importance of having spatial structure in ecological modeling to avoid overestimating predictor effects. E.g., SoilClim_PC2 went from being significant in the lm model to non-significant in the spatial model -> Species richness was not affected significantly by those soil parameters, but by spatial autocorrelation.*

# Challenge Exercises

## Challenge 1: Alternative Predictors
Reload the full dataset (`Splot_SppRichness_AllVars.csv`) and include additional environmental variables. Does this change your spatial correlation structure selection?

## Challenge 2: Directional Autocorrelation
Investigate whether spatial autocorrelation is the same in all directions (isotropic) or varies by direction (anisotropic). Use directional variograms.

## Challenge 3: Local vs. Global Models
Compare your global spatial model with local regression techniques (e.g., Geographically Weighted Regression). Which performs better?

## Challenge 4: Prediction Mapping
Create a prediction map showing estimated species richness across Europe based on your spatial model.

---

# References
